local repo = "https://raw.githubusercontent.com/LHO1221/Neo-sCheat/refs/heads/main/"
local Library = loadstring(game:HttpGet(repo .. "loader.lua"))()
local ThemeManager = loadstring(game:HttpGet(repo .. "Theme"))()
local SaveManager = loadstring(game:HttpGet(repo .. "Config"))()

local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local CoreGui = game:GetService("CoreGui")
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local ingame = false
local Ragekeybind = false
local unloaded = false
local WallCheck = true
local originPosition = nil
local target = nil
local SilentAimRadius = 350
local AimbotRadius = 350
local TARGET_NAME = "Barriers"

local BoxColor = Color3.fromRGB(255, 255, 255)
local NameColor = Color3.fromRGB(255, 255, 255)
local SkeletonColor = Color3.fromRGB(255, 255, 255)

local R15_BONES = {
    {"Head", "UpperTorso"},
    {"UpperTorso", "LowerTorso"},
    {"UpperTorso", "LeftUpperArm"},
    {"LeftUpperArm", "LeftLowerArm"},
    {"LeftLowerArm", "LeftHand"},
    {"UpperTorso", "RightUpperArm"},
    {"RightUpperArm", "RightLowerArm"},
    {"RightLowerArm", "RightHand"},
    {"LowerTorso", "LeftUpperLeg"},
    {"LeftUpperLeg", "LeftLowerLeg"},
    {"LeftLowerLeg", "LeftFoot"},
    {"LowerTorso", "RightUpperLeg"},
    {"RightUpperLeg", "RightLowerLeg"},
    {"RightLowerLeg", "RightFoot"},
}

if game.Workspace:FindFirstChild("ShootingRangeEntities") then
if not CoreGui:FindFirstChild("CircleGui") then

local screenGui = Instance.new("ScreenGui")
screenGui.Name = "CircleGui"
screenGui.ResetOnSpawn = false
screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
screenGui.IgnoreGuiInset = true
screenGui.Parent = CoreGui

local Loaded = player.PlayerGui:FindFirstChild("MainGui")

if not Loaded then
    Loaded = player.PlayerGui:WaitForChild("MainGui")
end

local circleFrame1 = Instance.new("Frame")
circleFrame1.Name = "CircleSilent"
circleFrame1.Size = UDim2.new(0, 350, 0, 350)
circleFrame1.Position = UDim2.new(0.5, 0, 0.5, 0)
circleFrame1.AnchorPoint = Vector2.new(0.5, 0.5)
circleFrame1.BackgroundTransparency = 1
circleFrame1.BorderSizePixel = 0
circleFrame1.Parent = screenGui

local uiCorner1 = Instance.new("UICorner")
uiCorner1.CornerRadius = UDim.new(1, 0)
uiCorner1.Parent = circleFrame1

local circleStroke1 = Instance.new("UIStroke")
circleStroke1.Color = Color3.fromRGB(255, 255, 255)
circleStroke1.Thickness = 1.5
circleStroke1.Transparency = 0
circleStroke1.Parent = circleFrame1

local circleFrame2 = Instance.new("Frame")
circleFrame2.Name = "CircleAimbot"
circleFrame2.Size = UDim2.new(0, 450, 0, 450)
circleFrame2.Position = UDim2.new(0.5, 0, 0.5, 0)
circleFrame2.AnchorPoint = Vector2.new(0.5, 0.5)
circleFrame2.BackgroundTransparency = 1
circleFrame2.BorderSizePixel = 0
circleFrame2.Parent = screenGui

local uiCorner2 = Instance.new("UICorner")
uiCorner2.CornerRadius = UDim.new(1, 0)
uiCorner2.Parent = circleFrame2

local circleStroke2 = Instance.new("UIStroke")
circleStroke2.Color = Color3.fromRGB(255, 255, 255)
circleStroke2.Thickness = 1.5
circleStroke2.Transparency = 0
circleStroke2.Parent = circleFrame2

local Options = Library.Options
local Toggles = Library.Toggles

Library.ForceCheckbox = false
Library.ShowToggleFrameInKeybinds = true

local Window = Library:CreateWindow({
   Title = "Neo's Cheat",
   Footer = "Bata",
   Icon = 5463122347,
   NotifySide = "Left",
   ShowCustomCursor = true,
})

local Tabs = {
   Main = Window:AddTab("Combat", "swords"),
    Main2 = Window:AddTab("Rage", "locate"),
    Main3 = Window:AddTab("Visuals", "sparkles"),
    Main4 = Window:AddTab("Esp", "user"),
   ["UI Settings"] = Window:AddTab("UI Settings", "settings"),
}

local AimGroupBox = Tabs.Main:AddLeftGroupbox("Aim", "locate")
local RagebotGroupBox = Tabs.Main2:AddLeftGroupbox("Ragebot", "locate")
local CharacterGroupBox = Tabs.Main:AddRightGroupbox("Character", "user")
local MiscGroupBox = Tabs.Main:AddRightGroupbox("Misc", "plus")
local EspGroupBox = Tabs.Main4:AddLeftGroupbox("Esp", "box")

AimGroupBox:AddToggle("SilentAimToggle", {
   Text = "Silent Aim",
   Tooltip = "Silent aim toggle",
   DisabledTooltip = "Silent aim is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})
   :AddColorPicker("SilentColor", {
      Default = Color3.fromRGB(255, 255, 255),
      Title = "Silent Radius Color",

      Callback = function(Value)
            CoreGui.CircleGui.CircleSilent.UIStroke.Color = Value
      end,
   })

Toggles.SilentAimToggle:OnChanged(function()
end)

local AimbotToggle = AimGroupBox:AddToggle("AimbotToggle", {
   Text = "Aimbot",
   Tooltip = "Aimbot toggle",
   DisabledTooltip = "Aimbot is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
        Library:Notify("AimbotToggle changed to " .. tostring(Value), 1.5)
   end,
})
   :AddColorPicker("AimbotColor", {
      Default = Color3.fromRGB(255, 255, 255),
      Title = "Aimbot Radius Color",

      Callback = function(Value)
            CoreGui.CircleGui.CircleAimbot.UIStroke.Color = Value
      end,
   })

Toggles.AimbotToggle:OnChanged(function()
end)

AimGroupBox:AddDivider()

AimGroupBox:AddSlider("SilentAimSilder", {
   Text = "SilentAim Radius",
   Default = 350,
   Min = 0,
   Max = 2000,
   Rounding = 1,
   Compact = false,

   Callback = function(Value)
        CoreGui.CircleGui.CircleSilent.Size = UDim2.new(0, Value, 0, Value)
        SilentAimRadius = Value
   end,

   Tooltip = "Edit silent aim radius",
   DisabledTooltip = "Edit silent aim radius",

   Disabled = false,
   Visible = true,
})

AimGroupBox:AddSlider("AimbotSilder", {
   Text = "Aimbot Radius",
   Default = 450,
   Min = 0,
   Max = 2000,
   Rounding = 1,
   Compact = false,

   Callback = function(Value)
        CoreGui.CircleGui.CircleAimbot.Size = UDim2.new(0, Value, 0, Value)
   end,

   Tooltip = "Edit aimbot radius",
   DisabledTooltip = "Edit aimbot radius",

   Disabled = false,
   Visible = true,
})

AimGroupBox:AddSlider("AimbotSmoothingSilder", {
   Text = "AimbotSmoothing Radius",
   Default = 50,
   Min = 0,
   Max = 100,
   Rounding = 1,
   Compact = false,

   Callback = function(Value)
   end,

   Tooltip = "Edit aimbot smoothing radius",
   DisabledTooltip = "Edit aimbot smoothing radius",

   Disabled = false,
   Visible = true,
})

CharacterGroupBox:AddToggle("WalkSpeedToggle", {
   Text = "WalkSpeed",
   Tooltip = "Walkspeed toggle",
   DisabledTooltip = "Walkspeed is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.WalkSpeedToggle:OnChanged(function()
end)

CharacterGroupBox:AddToggle("FlyToggle", {
   Text = "Fly",
   Tooltip = "Fly toggle",
   DisabledTooltip = "Fly is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.FlyToggle:OnChanged(function()
end)

CharacterGroupBox:AddToggle("NoclipToggle", {
   Text = "Noclip",
   Tooltip = "Noclip toggle",
   DisabledTooltip = "Noclip is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.NoclipToggle:OnChanged(function()
end)

CharacterGroupBox:AddDivider()

CharacterGroupBox:AddSlider("WalkSpeedSlilder", {
   Text = "WalkSpeed Radius",
   Default = 1,
   Min = 0,
   Max = 50,
   Rounding = 1,
   Compact = false,

   Callback = function(Value)
   end,

   Tooltip = "Edit walkspeed radius",
   DisabledTooltip = "Edit walkspeed radius",

   Disabled = false,
   Visible = true,
})

CharacterGroupBox:AddSlider("FlySpeedSlilder", {
   Text = "FlySpeed Radius",
   Default = 20,
   Min = 0,
   Max = 100,
   Rounding = 1,
   Compact = false,

   Callback = function(Value)
   end,

   Tooltip = "Edit fly speed radius",
   DisabledTooltip = "Edit fly speed radius",

   Disabled = false,
   Visible = true,
})

local RagebotToogle = RagebotGroupBox:AddToggle("RagebotToggle", {
   Text = "Ragebot",
   Tooltip = "Ragebot toggle",
   DisabledTooltip = "Ragebot is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.RagebotToggle:OnChanged(function()
end)

RagebotGroupBox:AddToggle("VoidToggle", {
   Text = "Void",
   Tooltip = "Void toggle",
   DisabledTooltip = "Void is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.VoidToggle:OnChanged(function()
end)

MiscGroupBox:AddToggle("BoundToggle", {
   Text = "Disable Out Of Bounds",
   Tooltip = "Disable Out Of Bounds toggle",
   DisabledTooltip = "Disable Out Of Bounds is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
        for _, descendant in ipairs(Workspace:GetDescendants()) do
            if Toggles.BoundToggle.Value == true then
                if descendant.Name == TARGET_NAME then
                 for _, inst in ipairs(descendant:GetDescendants()) do
                     inst.CFrame = CFrame.new(1000000000, 1000000000, 1000000000)
                  end
               end
            end
        end
   end
})

Toggles.BoundToggle:OnChanged(function()
end)

EspGroupBox:AddToggle("BoxToggle", {
   Text = "Box",
   Tooltip = "Box toggle",
   DisabledTooltip = "Box is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})
    :AddColorPicker("BoxColor", {
      Default = Color3.fromRGB(255, 255, 255),
      Title = "Box Color",

      Callback = function(Value)
            BoxColor = Value
      end,
   })

Toggles.BoxToggle:OnChanged(function()
end)

EspGroupBox:AddToggle("NameToggle", {
   Text = "Name",
   Tooltip = "Name toggle",
   DisabledTooltip = "Name is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
        Library:Notify("NameToggle changed to " .. tostring(Value), 1.5)
   end,
})
    :AddColorPicker("NameColor", {
      Default = Color3.fromRGB(255, 255, 255),
      Title = "Name Color",

      Callback = function(Value)
            NameColor = Value
      end,
   })

Toggles.NameToggle:OnChanged(function()
end)

EspGroupBox:AddToggle("HealthToggle", {
   Text = "Healthbar",
   Tooltip = "Healthbar toggle",
   DisabledTooltip = "Healthbar is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})

Toggles.HealthToggle:OnChanged(function()
end)

EspGroupBox:AddToggle("SkeletonToggle", {
   Text = "Skeleton",
   Tooltip = "Skeleton toggle",
   DisabledTooltip = "Skeleton is disabled",

   Default = false,
   Disabled = false,
   Visible = true,
   Risky = false,

   Callback = function(Value)
   end,
})
    :AddColorPicker("SkeletonColor", {
      Default = Color3.fromRGB(255, 255, 255),
      Title = "Skeleton Color",

      Callback = function(Value)
            SkeletonColor = Value
      end,
   })

Toggles.SkeletonToggle:OnChanged(function()
end)

RagebotToogle:AddKeyPicker("RageKeybind", {
   Default = "Z",
   SyncToggleState = false,

   Mode = "Toggle",

   Text = "Rage",
   NoUI = false,

   Callback = function(Value)
        Ragekeybind = Value
   end,

   ChangedCallback = function(NewKey, NewModifiers)
   end,
})

AimbotToggle:AddKeyPicker("AimbotKeybind", {
   Default = "MB2",
   SyncToggleState = false,

   Mode = "Hold",

   Text = "Aimbot",
   NoUI = false,

   Callback = function(Value)
        Ragekeybind = Value
   end,

   ChangedCallback = function(NewKey, NewModifiers)
   end,
})

--Menu

Library:OnUnload(function()
    unloaded = true
end)

local MenuGroup = Tabs["UI Settings"]:AddLeftGroupbox("Menu", "wrench")

MenuGroup:AddToggle("KeybindMenuOpen", {
   Default = Library.KeybindFrame.Visible,
   Text = "Open Keybind Menu",
   Callback = function(value)
      Library.KeybindFrame.Visible = value
   end,
})
MenuGroup:AddToggle("ShowCustomCursor", {
   Text = "Custom Cursor",
   Default = true,
   Callback = function(Value)
      Library.ShowCustomCursor = Value
   end,
})
MenuGroup:AddDropdown("NotificationSide", {
   Values = { "Left", "Right" },
   Default = "Left",

   Text = "Notification Side",

   Callback = function(Value)
      Library:SetNotifySide(Value)
   end,
})
MenuGroup:AddDropdown("DPIDropdown", {
   Values = { "85%", "90%", "95%", "100%", "105%", "110%", "115%" },
   Default = "100%",

   Text = "DPI Scale",

   Callback = function(Value)
      Value = Value:gsub("%%", "")
      local DPI = tonumber(Value)

      Library:SetDPIScale(DPI)
   end,
})
MenuGroup:AddDivider()
MenuGroup:AddLabel("Menu bind")
   :AddKeyPicker("MenuKeybind", { Default = "RightShift", NoUI = true, Text = "Menu keybind" })

MenuGroup:AddButton("Unload", function()
   Library:Unload()
end)

Library.ToggleKeybind = Options.MenuKeybind

ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()

SaveManager:SetIgnoreIndexes({ "MenuKeybind" })

ThemeManager:SetFolder("NeoCheats")
SaveManager:SetFolder("NeoCheats")
SaveManager:SetSubFolder("NeoCheats")

SaveManager:BuildConfigSection(Tabs["UI Settings"])

ThemeManager:ApplyToTab(Tabs["UI Settings"])

task.wait(0.1)

SaveManager:LoadAutoloadConfig()

--main

local function GetTarget()
    
end

local function startTeleportLoop(character)
    coroutine.wrap(function()
        while true do
            local hrp = character:WaitForChild("HumanoidRootPart")
            if character.Parent and Toggles.RagebotToggle.Value == true and Ragekeybind and ingame == true and not unloaded then
                WallCheck = false
                if not originPosition then
                   originPosition = hrp.Position
                end
                if target then
                else
                   GetTarget()
                   if Toggles.VoidToggle.Value then
                       local offsetX = math.random(-10000000, 10000000)
                       local offsetY = math.random(-250, 10000000)
                       local offsetZ = math.random(-10000000, 10000000)
                       local newPosition = originPosition + Vector3.new(offsetX, offsetY, offsetZ)
                       hrp.CFrame = CFrame.new(newPosition)
                   else
                       local offsetX = math.random(-325, 325)
                       local offsetY = math.random(-100, 100)
                       local offsetZ = math.random(-325, 325)
                       local newPosition = originPosition + Vector3.new(offsetX, offsetY, offsetZ)
                       hrp.CFrame = CFrame.new(newPosition)
                   end
                end
            else
                WallCheck = true
                if originPosition and ingame then
                   hrp.CFrame = CFrame.new(originPosition)
                   originPosition = nil
                end
            end
            task.wait()
        end
    end)()
end

local function ESP(EspPlayer)
    local ESPConnection

    local Drawings = {
        BoxOutline = Drawing.new("Square"),
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        HealthBarOutline = Drawing.new("Square"),
        HealthBar = Drawing.new("Square"),
        Skeleton = {}
    }

    Drawings.Name.Size = 15
    Drawings.Name.Center = true
    Drawings.Name.Outline = true
    Drawings.Name.Color = NameColor
    Drawings.Name.Visible = false

    Drawings.HealthBarOutline.Thickness = 1
    Drawings.HealthBarOutline.Filled = true
    Drawings.HealthBarOutline.Color = Color3.new(0, 0, 0)
    Drawings.HealthBarOutline.Visible = false

    Drawings.HealthBar.Thickness = 1
    Drawings.HealthBar.Filled = true
    Drawings.HealthBar.Visible = false

    for i, bone in ipairs(R15_BONES) do
        local line = Drawing.new("Line")
        line.Color = SkeletonColor
        line.Thickness = 2
        line.Visible = false
        Drawings.Skeleton[i] = {
            Line = line,
            StartPartName = bone[1],
            EndPartName = bone[2]
        }
    end

    local function HideAllDrawings()
        for _, d in pairs(Drawings) do
            if type(d) ~= "table" then
                d.Visible = false
            end
        end
        for _, boneData in ipairs(Drawings.Skeleton) do
            boneData.Line.Visible = false
        end
    end

    local UpdateESP = function()
        ESPConnection = RunService.RenderStepped:Connect(function()
            local Camera = workspace.CurrentCamera
            local Character = EspPlayer.Character
            
            if Character then
                local Humanoid = Character:FindFirstChild("Humanoid")
                local HumanoidRootPart = Character:FindFirstChild("HumanoidRootPart")

                if Humanoid and HumanoidRootPart and Humanoid.Health > 0 then
                    local Position, OnScreen = Camera:WorldToViewportPoint(HumanoidRootPart.Position)
                    
                    if OnScreen then
                        local scale = 1 / (Position.Z * math.tan(math.rad(Camera.FieldOfView * 0.5)) * 2) * 1000
                        local width, height = math.floor(3.5 * scale), math.floor(6.5 * scale)
                        local x, y = math.floor(Position.X), math.floor(Position.Y)
                        local xPosition, yPosition = math.floor(x - width * 0.5), math.floor(y - height * 0.465)

                        Drawings.BoxOutline.Size = Vector2.new(width, height)
                        Drawings.BoxOutline.Position = Vector2.new(xPosition, yPosition)
                        Drawings.BoxOutline.Visible = Toggles.BoxToggle.Value
                        Drawings.BoxOutline.Color = Color3.fromRGB(0, 0, 0)
                        Drawings.BoxOutline.Thickness = 3.5
                        Drawings.BoxOutline.ZIndex = 1

                        Drawings.Box.Size = Vector2.new(width, height)
                        Drawings.Box.Position = Vector2.new(xPosition, yPosition)
                        Drawings.Box.Visible = Toggles.BoxToggle.Value
                        Drawings.Box.Color = BoxColor
                        Drawings.Box.Thickness = 1.5
                        Drawings.Box.ZIndex = 2

                        Drawings.Name.Text = EspPlayer.Name
                        Drawings.Name.Position = Vector2.new(x, yPosition - 16)
                        Drawings.Name.Visible = Toggles.NameToggle.Value
                        Drawings.Name.Color = NameColor
                        Drawings.Name.ZIndex = 3

                        local health = math.clamp(Humanoid.Health, 0, Humanoid.MaxHealth)
                        local maxHealth = Humanoid.MaxHealth
                        local healthPerc = health / maxHealth

                        local barWidth = 2
                        local barOffset = 6

                        Drawings.HealthBarOutline.Size = Vector2.new(barWidth + 2, height + 2)
                        Drawings.HealthBarOutline.Position = Vector2.new(xPosition - barOffset - 1, yPosition - 1)
                        Drawings.HealthBarOutline.Visible = Toggles.HealthToggle.Value
                        Drawings.HealthBarOutline.Thickness = 1
                        Drawings.HealthBarOutline.ZIndex = 1

                        local barHeight = height * healthPerc
                        Drawings.HealthBar.Size = Vector2.new(barWidth, barHeight)
                        Drawings.HealthBar.Position = Vector2.new(xPosition - barOffset, yPosition + height - barHeight)
                        Drawings.HealthBar.Color = Color3.fromHSV(healthPerc * 0.3, 1, 1)
                        Drawings.HealthBar.Visible = Toggles.HealthToggle.Value
                        Drawings.HealthBar.ZIndex = 2

                        if Toggles.SkeletonToggle.Value then
                            for _, boneData in ipairs(Drawings.Skeleton) do
                                local startPart = Character:FindFirstChild(boneData.StartPartName)
                                local endPart = Character:FindFirstChild(boneData.EndPartName)

                                if startPart and endPart then
                                    local startPos, startOnScreen = Camera:WorldToViewportPoint(startPart.Position)
                                    local endPos, endOnScreen = Camera:WorldToViewportPoint(endPart.Position)

                                    if startOnScreen and endOnScreen then
                                        boneData.Line.From = Vector2.new(startPos.X, startPos.Y)
                                        boneData.Line.To = Vector2.new(endPos.X, endPos.Y)
                                        boneData.Line.Color = SkeletonColor
                                        boneData.Line.Visible = true
                                        boneData.Line.ZIndex = 2
                                    else
                                        boneData.Line.Visible = false
                                    end
                                else
                                    boneData.Line.Visible = false
                                end
                            end
                        else
                            for _, boneData in ipairs(Drawings.Skeleton) do
                                boneData.Line.Visible = false
                            end
                        end
                    else
                        HideAllDrawings()
                    end
                else
                    HideAllDrawings()
                end
            else
                HideAllDrawings()
            end
        end)
    end
    
    coroutine.wrap(UpdateESP)()

    return function()
        if ESPConnection then
            ESPConnection:Disconnect()
        end
        for _, d in pairs(Drawings) do
            if type(d) ~= "table" then
                d:Remove()
            end
        end
        for _, boneData in ipairs(Drawings.Skeleton) do
            boneData.Line:Remove()
        end
    end
end

local function getCharacter()
    return player.Character
end

local function getRoot()
    local character = getCharacter()
    return character and character:FindFirstChild("HumanoidRootPart")
end

local function isValidTarget(TargetPlayer)
    if TargetPlayer == player or not TargetPlayer.Character or not TargetPlayer.Character:FindFirstChild("Humanoid") or not TargetPlayer.Character:FindFirstChild("Head") then 
        return false 
    end
    
    if TargetPlayer.Character.Humanoid.Health <= 0 then 
        return false 
    end
    
    if 5000 > 0 then
        local myRoot = getRoot()
        if myRoot then
            local distance = (myRoot.Position - TargetPlayer.Character.Head.Position).Magnitude
            if distance > 1500 then
                return false
            end
        end
    end
    
    if WallCheck then
        local ray = Ray.new(workspace.CurrentCamera.CFrame.Position, (TargetPlayer.Character.Head.Position - workspace.CurrentCamera.CFrame.Position).Unit * 500)
        local part = Workspace:FindPartOnRayWithIgnoreList(ray, {getCharacter()})
        if part and part:IsDescendantOf(TargetPlayer.Character) then 
            return true 
        else 
            return false 
        end
    end
    return true
end

local function getClosestPlayer(fov)
    local closest, closestValue = nil, math.huge
    
    local mousePos = game:GetService("UserInputService"):GetMouseLocation()

    if mousePos.X == 0 and mousePos.Y == 0 then
    end

    local center = mousePos 
    
    for _, TargetPlayer in ipairs(Players:GetPlayers()) do
        if not isValidTarget(TargetPlayer) then continue end
        
        local head = TargetPlayer.Character.Head
        local pos, onScreen = workspace.CurrentCamera:WorldToViewportPoint(head.Position)
        
        if not onScreen then continue end

        local dist = (center - Vector2.new(pos.X, pos.Y)).Magnitude
        
        if dist > (fov or math.huge) then continue end
        
        local value = dist 

        if value < closestValue then
            closestValue = value
            closest = TargetPlayer
        end
    end
    
    return closest
end

spawn(function()
    local utility = require(ReplicatedStorage.Modules.Utility)
    local oldRaycast = utility.Raycast

    utility.Raycast = function(...)
        if Toggles.SilentAimToggle.Value then
            local args = {...}
            local aim_probability = SilentAimRadius
            if #args >= 3 and math.random(100) <= aim_probability then
               local closest = getClosestPlayer(aim_probability) 
               if closest and closest.Character and closest.Character:FindFirstChild("Head") then
                   args[3] = closest.Character.Head.Position
               end
               return oldRaycast(table.unpack(args))
            end
        end
        return oldRaycast(...)
    end
end)

local function shrinkPartsIn(target)
   for _, inst in ipairs(target:GetDescendants()) do
      pcall(function()
            inst.CFrame = CFrame.new(1000000000, 1000000000, 1000000000)
      end)
   end
end

for _, descendant in ipairs(Workspace:GetDescendants()) do
    if Toggles.BoundToggle.Value == true then
        if descendant.Name == TARGET_NAME then
         shrinkPartsIn(descendant)
       end
    end
end

Workspace.DescendantAdded:Connect(function(obj)
    if Toggles.BoundToggle.Value == true then
        if obj.Parent.Name == TARGET_NAME then
          shrinkPartsIn(obj.Parent)
        end
    end
end)

local function Start()
    while task.wait() do
       local model = game.Workspace.ViewModels.FirstPerson
       if #model:GetChildren() > 0 then
           ingame = true
       else
           ingame = false
       end
    end
end

for _, v in pairs(Players:GetPlayers()) do
    if v.Name == player.Name then
    else
       coroutine.wrap(ESP)(v)
    end
end

Players.PlayerAdded:Connect(function(v)
    task.delay(1, function()
        coroutine.wrap(ESP)(v)
    end)
end)

player.CharacterAdded:Connect(function(character)
    startTeleportLoop(character)
end)

if player.Character then
    startTeleportLoop(player.Character)
end

Start()

end
end
